## 多遍扫描机制

最初的设计是使用多遍扫描，提前扫描已知的类型和函数声明，达到能够访问后面定义定义的函数，以及实现交叉引用。

但多遍扫描成本颇高，在import的时候更为明显

首先对于单个文件考虑，多遍扫描需要6趟才能完整扫描整个文件

首先是宏定义，其次是宏展开
再者是类型名，其次是类型定义
最后是函数类型，最后是函数本身

这些环节层层依赖，非常复杂。


## Lazy思想

解决这种问题的一个重要思想就是Lazy思想，尽量推迟具体执行的动作。

可以分成两个过程，首先是记录
宏遇到定义，就只记录一个定义名，到了展开时，再去找具体的实现
类型，并不展开记录细节，而是等用到类型细节时，再去解析其细节
函数，只是记录函数名，等用到参数表和类型时，再去解析参数表
类，只记录类名
import也记录一个import的符号和对应的引用，并不真的载入这个文件
当然，这个过程如果遇到了宏展开，和直接的可执行语句，也是会触发寻找具体内容的过程，有可能提前对文件进行import

之后进入执行环节
扫描文件内的所有的函数和所有的类，还有import进来的所有内容，依次进行代码生成，对函数生成完整的函数类型
依次解析所有用到的内容。
如果用到了import的内容，此时开始递归解析import的文件，也是先扫描，再执行代码生成两步走

lazy思想的最坏情况和多趟扫描是一样的，但大多数情况都不是这样，能够更为高效地找到所需要的内容

## 符号表的改进

这一版的符号表添加两个新功能，对别名alias的映射，可以将任意一个名称映射成别的名称使用，重新在该符号表的作用范围内寻找可用的符号。
这个功能的实现非常简单，只需设置一个特别的alias类型，无论什么对象结构，在查找时，发现最终映射到的是alias，则进行一次重新寻找。

另一个重要功能是添加了新的map类型，能够支持一个名称下，设置多个名称对象，类似于namespace的作用，主要是名称空间的划定。
然而此功能和Struct不同，无需名称下的特定结构，名称下可以支持任意一种类型的成员。

